

 1. There will be a `input.txt` where there will be passwords
 2. Key-value pair like `GEMINI_API_CODE = "sk-***"` and such
 3. The user will do command line like `make_vault file1.txt`, it can be multiple or single file
 4. While making a vault, the system will give me an SSH key, public-private in a file
 5. After that, a file will be generated in the project root â€” e.g., `gen1.vault` â€” where if I want to visit it in VSCode, I click the file and see an interface mentioning what keys are there **visually**, but it **wonâ€™t show the values**
 6. I can call from the file like `gen1.get('openai_key')` or something like `.env` file usage
 7. I canâ€™t print or see the key values in code â€” only pass to API
 8. Added implementation: I can implement **rate limiter** for each API, maybe fine-grain control for each API key or overall as a whole
 9. Make a **dashboard** about the vault files: which files are used how many times, which APIs are used how many times
    â€ƒâ€ƒâ€¢ Rate limiter can be controlled from there
    â€ƒâ€ƒâ€¢ Can block any file, modify, add env variables


 ğŸ” **New addition**: A local **in-memory secured binary runtime (agent)** will be generated with the vault.
 â€ƒâ€ƒâ€¢ This binary will decrypt values only during execution
 â€ƒâ€ƒâ€¢ It avoids repeated DB lookup by keeping values securely in memory
 â€ƒâ€ƒâ€¢ This binary is iron-clad â€” encrypted state tracking and tamper protection
 â€ƒâ€ƒâ€¢ Usage limits and API call counters will be tracked locally in a binary `.state` file
 â€ƒâ€ƒâ€¢ This allows secure, offline access without leaking secrets or overusing keys



 Implementation details:

 1. To merge two `.vault` files
 2. Effective hashing (maybe Merkle tree)
 3. Secure offline usage with binary runtime agent


